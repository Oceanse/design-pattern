package structuremode.proxypattern.staticproxy.demo1;


/**
 * 代理模式的核心是通过代理对象间接访问目标对象，可以灵活添加各种功能，尤其在权限控制、日志记录和延迟加载中非常实用。
 *
 * 角色：
 * 抽象主题（Subject）：定义目标对象和代理对象的公共接口。
 * 真实主题（RealSubject）：实现具体的业务逻辑。
 * 代理（Proxy）：继承并关联真实主题，并在调用真实主题方法时可以添加额外的功能。
 *
 *
 *静态代理优点：
 * 控制访问：代理对象可以对目标对象的访问进行控制，例如在企业系统中，某些功能只有管理员可以操作，通过代理对象对权限进行校验。
 * 扩展目标对象功能：代理模式可以在不修改目标对象代码的情况下，动态添加额外功能，例如在数据库操作中，通过代理管理事务，确保操作的原子性。
 * 可维护性：代理模式将目标对象的核心功能与其他附加职责（如日志、权限控制等）分离开，目标对象专注于业务逻辑，代理对象负责附加功能的处理。
 * 可扩展性：通过新增代理类来扩展功能，无需修改目标对象的代码，实现对功能扩展的开放、对修改的关闭。
 * 透明性高：代理模式对客户端是透明的，客户端无需关心目标对象与代理对象的区别，只需面向公共接口编程。
 *
 * 静态代理模式缺点：
 * 类爆炸：每个目标类都需要对应一个代理类，尤其在目标类较多的情况下，会导致代理类数量激增。一个系统中有多个服务接口（如 UserService、OrderService、ProductService），每个服务都需要日志功能，则需要为每个接口编写独立的代理类。
 * 可维护性差：由于静态代理直接绑定了具体的接口或类，导致代理类与目标类的耦合度较高。如果接口发生变化，例如新增或删除方法，所有对应的代理类都需要同步修改，维护成本很高。
 *
 * 静态代理的缺点主要集中在开发成本高和灵活性不足上。虽然它适合一些简单场景，但在需求复杂、目标接口较多的情况下，动态代理是更高效的选择。
 * 对于大规模系统开发，动态代理的优势更为明显，因此静态代理往往用于学习和理解代理模式的基本原理。
 *
 * 静态代理使用场景：
 * 权限控制：使用代理对象限制某些用户访问目标对象的功能。
 * 日志记录：在方法调用前后添加日志记录功能。
 * 性能监控：统计方法执行的时间或资源消耗。
 * 事务管理：在方法调用前后控制事务的提交与回滚。
 * 缓存处理：在代理对象中检查是否已有缓存数据，避免不必要的实际调用。
 *
 *
 */
public class StaticProxyDemo {
    public static void main(String[] args) {
        // 创建真实对象
        UserService realService = new UserServiceImpl();
        // 创建代理对象
        UserService proxyService = new UserServiceProxy(realService);

        // 使用代理对象调用方法
        proxyService.addUser("Alice");
    }
}

