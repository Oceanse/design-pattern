package createmode.builderpattern.demo1;

/**
 * 基本概念：
 * 没有人买车会只买一个轮胎或者方向盘，大家买的都是一辆包含轮胎、方向盘和发动机等多个部件的完整汽车。如何将这些部件组装成一辆完整的汽车并返回给用户，这是建造者模式需要解决的问题。
 * 建造者模式为客户端返回的不是一个简单的产品，而是一个由多个部件组成的复杂产品，各个复杂产品的创建步骤都大同小异，都需要逐步创建其组成部分，再将各组成部分装配成一个完整的产品，
 * 如何一步步创建一个包含多个组成部分的复杂对象，建造者模式为解决此类问题而诞生。
 * 建造者模式(Builder Pattern)：将一个复杂对象的构建与表示分离，使得同样的构建流程可以创建不同的产品。
 *
 * 建造者模式中的角色：
 * Product（产品角色）：它是被构建的复杂对象，包含多个组成部件，具体建造者创建该产品的内部表示并定义它的装配过程
 *
 * Builder（抽象建造者）：它为创建一个产品Product对象的各个部件指定抽象接口，在该接口或者抽象类中一般声明一个成员变量和两类方法
 * 成员变量是产品类对象：Product product=new product();
 * 一类方法是buildPartX()，它们用于创建复杂对象的各个部件
 * 另一类方法是getResult()，它们用于返回复杂对象
 *
 * ConcreteBuilder（具体建造者）：它实现了Builder接口，实现各个部件的具体构造和装配方法
 *
 * Director（指挥者）：指挥者又称为导演类，它负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其construct()建造方法中调用建造者对象的部件构造与装配方法，
 * 完成复杂对象的建造。客户端一般只需要与指挥者进行交互，在客户端确定具体建造者的类型
 *
 *
 * 使用场景：
 * 1 产品的创建过程复杂，需要通过一系列的步骤来创建或者说创建的对象是一个复杂对象，复杂对象是指那些包含多个成员属性的对象，这些成员属性也称为部件或零件，如汽车包括方向盘、发动机、轮胎等部件，电子邮件包括发件人、收件人、主题、内容、附件等部件
 * 2 所有产品的创建流程相似，可以通过相似的创建流程创建出不同的产品，如果产品之间的差异性很大，意味着创建流程相差较大，那么就不适合使用建造者模式
 *
 * 优点：
 *
 * (1) 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，相同的创建过程可以创建不同的产品对象
 * (2) 增加新的具体建造者无需修改原有类库的代码，指挥者类针对抽象建造者类编程，不需要进行改动，系统扩展方便，符合“开-闭”原则
 *
 * 缺点：
 * (1) 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，例如很多组成部分都不相同，不适合使用建造者模式，因此其使用范围受到一定的限制。
 * (2) 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，增加系统的理解难度和运行成本。
 *
 * 抽象工厂模式 vs 建造者模式
 * 抽象工厂模式生产一系列相关的产品，客户端通过选择具体工厂来生成所需对象
 * 建造者模式中侧重于一步步构造一个复杂对象，然后将结果返回。如如果将抽象工厂模式看成一个汽车配件生产厂，生成不同类型的汽车配件，那么建造者模式就是一个汽车组装厂，通过对配件进行组装返回一辆完整的汽车。
 *
 *
 *
 *
 */
public class Client {
    public static void main(String[] args) {
        // 创建普通房子建造者，同时初始化了房子对象
        CommonHouseBuilder commonHouseBuilder = new CommonHouseBuilder();
        // 创建建造房子的指挥者，指挥者指挥建造者来建造房子
        HouseDirector houseDirector = new HouseDirector(commonHouseBuilder);
        // 完成盖房子
        House commonHouse = houseDirector.constructHouse();
        System.out.println("commonHouse = " + commonHouse);
        System.out.println();

        // 盖高楼
        houseDirector.setHouseBuilder(new HighBuildingBuilder());
        // 完成盖房子
        House highBuilding = houseDirector.constructHouse();
        System.out.println("highBuilding = " + highBuilding);

    }

}
