package structuremode.facade.demo1;

/**
 * 门面模式对客户端提供一个统一的接口, 客户端只需要调用门面类的统一入口方法即可完成对多个子系统的复杂调用而不必关心子系统的具体实现细节
 * 门面模式的核心目的是降低复杂性
 *
 * 主要角色：
 * 门面类（Facade）：将复杂的子系统功能封装起来，为多个子系统对外提供一个统一的接口。
 * 子系统（Sub System）：提供了系统的核心业务逻辑
 * 客户端(client): 调用门面类来访问系统功能，而无需直接与子系统交互
 *
 * 优点:
 * 简洁易用：客户端只需要调用门面类的方法即可完成对多个子系统的复杂调用，而不必直接与多个子系统交互。
 * 松耦合：门面类将客户端与子系统解耦，使得客户端不必关心子系统的具体实现细节，子系统的变更不会直接影响客户端。
 * 提高安全性：门面类可以作为系统的安全边界，控制对外暴露的接口，防止外部代码直接访问子系统。
 *
 * 缺点：
 * 门面模式的缺点
 * 增加复杂性：虽然门面模式简化了客户端与子系统的交互，但在某些情况下，引入门面可能会增加系统的复杂性，尤其是在子系统本身已经很简洁的情况下。
 * 性能开销：门面模式在客户端和子系统之间增加了一层间接调用，可能会引入额外的性能开销，尽管这种开销通常很小。
 * 过度抽象：有时候，门面模式可能会导致过度抽象，即为了封装而封装，使得系统设计变得不够自然。
 * 隐藏复杂性：门面模式隐藏了子系统的复杂性，这可能会导致问题难以定位，特别是在门面类中处理错误和异常时。
 * 限制灵活性：门面模式提供了一个简化的接口，但如果客户端需要访问子系统中的一些特定功能，可能需要绕过门面类，直接与子系统交互，这会破坏门面模式的初衷。
 *
 * 使用场景
 * 当一个系统由多个子系统组成，每个子系统可能有多个复杂接口时，直接让客户端调用这些接口会显得繁琐，门面模式可以为系统设计一个统一的接口供外界访问。
 * 电商系统中的订单服务由库存系统、支付系统和物流系统支持。通过门面模式，提供统一的订单管理接口，屏蔽复杂的业务逻辑。
 * 微服务架构中的 API 网关（API Gateway）作为门面，统一处理外部请求，协调多个内部微服务。
 *
 * 当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。

 */
public class Client {
    public static void main(String[] args) {
        //创建外观对象
        SmartAppliancesFacade facade = new SmartAppliancesFacade();
        //客户端直接与外观对象进行交互
        facade.say("打开家电");
        facade.say("关闭家电");
    }
}
