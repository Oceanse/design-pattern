package createmode.factorypattern.abstractfactory.demo1;

/**
 *
 *
 *
 *
 *

 *
 *
 * 概念补充：
 * (1) 产品等级结构：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，
 *     则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。
 *
 * (2) 产品族：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，
 *    海尔电冰箱位于电冰箱产品等级结构中，海尔电视机、海尔电冰箱构成了一个产品族，常见的一个例子就是统一品牌下的不同产品构成一个产品族。
 *
 * 在工厂方法模式中，解决了简单工厂模式中工厂类职责太重的问题， 我们使用一个工厂创建一类产品，这样可能会导致系统中存在大量的工厂类，增加系统复杂度；
 * 比如这里有华为手机、苹果手机、华为pad、苹果pad四种产品，那么我们就需要设计四个具体工厂来生产这四种产品；此时，我们可以考虑将一些相关的产品组成一个“产品族”，由同一个工厂来统一生产，
 * 我们需要一个工厂能够提供多个产品对象，而不是单一的对象，这个时候我们就需要使用抽象工厂模式。
 * 在抽象工厂模式中，每一个具体工厂都提供了多个工厂方法用于产生多种不同类型的产品，这些产品构成了一个产品族，比如AppleFactory生产iphone和ipad；
 * 抽象工厂的作用就是在一定前提下，帮你分类这些工厂，比如按品牌分类：AppleFactory和HuaweiFactory，AppleFactory生产一族产品，HuaweiFactory生产一族产品，这样会大大缩减系统中的工厂数量。
 *
 * 角色：
 * AbstractFactory（抽象工厂）：它声明了一组用于创建一族产品（一个产品族）的方法，每一个方法对应一种产品。
 * ConcreteFactory（具体工厂）：它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。
 *
 * 关于开闭原则：
 * (1) 增加产品族：对于增加新的产品族 抽象工厂模式很好地支持了“开闭原则”，只需要增加具体产品并对应增加一个新的具体工厂，比如增加XiaomiFactory, 可以生产新的一组产品，对已有代码无须做任何修改。
 * (2) 增加新的产品等级结构：对于增加新的产品等级结构，比如当前案例新增生产笔记本电脑，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，违背了“开闭原则”，这也是抽象工厂模式最大的缺点
 * 在抽象工厂模式中，增加新的产品族很方便，但是增加新的产品等级结构很麻烦，抽象工厂模式的这种性质称为“开闭原则”的倾斜性，为增加新产品族提供方便，但不能为增加新产品结构提供这样的方便，因此要求设计人员在设计
 * 之初就能够全面考虑，不会在设计完成之后向系统中增加新的产品等级结构，也不会删除已有的产品等级结构，否则将会导致系统出现较大的修改，为后续维护工作带来诸多麻烦。
 */
public interface Factory {
    Phone createPhone();
    Pad createPad();
}

class AppleFactory implements Factory{

    @Override
    public Phone createPhone() {
        return new IPhone();
    }

    @Override
    public Pad createPad() {
        return new IPad();
    }
}


class HuaweiFactory implements Factory{

    @Override
    public Phone createPhone() {
        return new HuaweiPhone();
    }

    @Override
    public Pad createPad() {
        return new HuaweiPad();
    }
}
